# 2022-2023 学年 秋冬学期 期末复习

本页面针对 2022-2023 学年 zkg 老师划定的范围进行复习，其他内容因时间关系不详细展开。以下目录基于《计算机网络》（第六版）[美] Andrew S. Tanenbaum 等 著。

## 第一章 引言（小于10分）

### 1.5 网络协议

### 1.6 参考模型（OSI）*

## 第2章 物理层（小于10分）
### 2.1 导向的传输介质

**导向传输介质Guided trans media**

- 磁介质
- 双绞线 twisted pair：绞合以减少相邻导线的电磁干扰在双绞线外加一层金属丝编织的屏蔽层，可以进一步提高抗电磁干扰的能力，称为屏蔽双绞线 STP（Shielded Twisted Pair）；没有屏蔽层的称为非屏蔽双绞线 UTP（Unshielded Twisted Pair）。
- 同轴电缆 coaxial cable
- 光纤 fiber optics：

*补充：**非导向传输介质 / 无线传输Wireless transmission**

- 无线电波 Radio有较强的的穿透能力，不需对准某个方向；无线手机通信、WLAN (wireless local area network) 等；
- 微波、红外线、激光有很强的方向性，沿直线传播。

注意区分 S/N ratio 和以 dB 为单位的两种信噪比，前者就是 S/N，后者是 10$\log_{10}$S/N。

semiconductor laser：半导体激光

注意区分 data transfer rate 数据传输速率和 signal propagation rate 信号传播速率，前者指数据发送到链路上的速率，单位为 b/s，后者指在链路上的传播速率（如电磁波在真空中传播速率为光速），单位 m/s。**计算数据传输速率要特别注意不要混淆 byte 和 bit，然后注意文件大小 K，M 等是以 2 为底的指数，传输速率是以 10 为底的指数。

下图为电话网络的基本结构：

![](./assets/tel-1.png)

其中 end office 为端局，toll office 为长途局，二者间连接为中继线。

Full Duplex 全双工

### 2.4 从波形到比特*

数据与代表它们的信号之间的转换过程称为数字调制 digital modulation

**基带传输 Baseband Transmission**

直接将数据转换为数字信号，数字信号是离散的。这里我们讨论的其实是对比特流进行编码（在课本中这部分也称为调制）；在通带传输中我们讨论真正的调制，即将数据转换为连续的模拟信号。

- ![img](https://cdn.nlark.com/yuque/0/2021/png/641515/1633520544956-bc74c216-0d3a-4f31-a9bc-9c873e979802.png)
- NRZ   Non-Return to Zero用正电压 / 有光表示 1，负电压 / 没有光表示 0。问题：如果是 0 和 1 交替，接收端可以在每一次变化时校准；但是如果一直是 0 或者 1 的话那过一段时间可能就数错了。即：无法传递时钟信号，双方难以同步；除非双方都带有时钟线。
- Manchester （以太网 Ethernet 的编码方式）用一个高和一个低表示 1，一个低一个高表示 0（实际上就是与一个时钟信号做了 XOR，如图）。解决了时钟信号的问题，即每个码元中间一定有电平跳变。问题是带宽开销增大了一倍。
- NRZI   NRZ Invert（USB 2.0 的编码方式）用信号翻转表示 1，信号不变表示 0。没有带宽开销的增加；解决了一长串都是 1 的问题；但是如果一长串都是 0 还是不行。4B/5B mapping 解决了这个问题，保证映射结果永远不会出现连续 3 个 0，虽然增加了 25% 的开销，但是比 Manchester 好一些：

- - ![img](https://cdn.nlark.com/yuque/0/2021/png/641515/1633523381106-d1b4375f-e32a-418d-9076-25e469479b0a.png)

- 扰频/倒频 scrambling尝试解决一长串 0 和 1 的问题。发送数据之前，用一个伪随机序列 XOR 数据，接收器用同样的序列 XOR 后得到结果。问题：不能完全保证不会出现一长串 0 或 1；尤其是序列较短之类的情况可能出错或被恶意用户攻击。
- 双极编码 bipolar encoding / AMI, Alternate Mark Inversion这种编码方式关注信号的平衡性；短时间内正电压和负电压一样多的信号称为平衡信号 balanced signal，这样的信号均值为 0，即没有直流分量；由于传输介质的物理性质，没有直流分量是一个优点。这种编码方式用 +1 或者 -1 表示 1，每次的 1 与前一次的 1 表示法相反，保证最多只差 1 个；用 0 表示 0。
- 还有一种 8B/10B 编码模式 同时考虑这些问题，通过映射保证没有超过 5 个连续的 0 或 1，同时保持 0 和 1 数目相对均等；其额外带宽消耗也只有 25%。

**通带传输 Passband Transmission**

通过调节载波信号的幅值、相位或频率来运载数据，占据以载波信号频率为中心的一段频带，用于无线和光纤信道。

- 幅移键控 ASK, Amplitude Shift Keying通过两个不同的振幅分别表示 0 和 1；可以用更多的幅值等级表示更多的信息。
- 频移键控 FSK, Frequency Shift Keying类似地，通过不同频率表示不同的码元。
- 相移键控 PSK, Phase Shift Keying将载波波形偏移一定的相位。二进制相移键控 BPSK, Binary PSK 将波形偏移 0° 和 180°；正交相移键控 QPSK, Quadrature PSK 将波形偏移 45°, 135°, 225° 和 315°。
- 为了让每个码元传输更多 bit 的信息，也可以将这些方式综合起来使用。下面的 星座图 constellation diagram 中用黑点表示一个合法的振幅和相位的组合；其中每个黑点到原点的距离表示振幅，和 x 轴正方向所成角度表示相位偏移。该图中 (a) 即为前述 QPSK，而后面两个图是 正交调幅 QAM, Quadrature Amplitude Modulation 的两个实例，它们的每个 symbol 分别携带 4 bit 和 6 bit 的信息。
- ![img](https://cdn.nlark.com/yuque/0/2021/png/641515/1633615422512-396a594f-5b18-4337-9121-1dff2a4b94ed.png)
- 为星座图分配每个黑点代表的 bit 时，需要考虑少量的突发噪音不会导致很多 bit 出错。可以使用 Gray code 解决这一问题。
- ![img](https://cdn.nlark.com/yuque/0/2021/png/641515/1633615696410-390e669f-92fe-4e94-a378-b39842f5863a.png)

**多路复用**

* 频分复用 FDM, Frequency Division Multiplexing：将信道带宽分割为多种不同频带的子信道，实现多路复用。每个频带之间保留足够宽的距离，保证相邻的频带不会相互重叠。这一部分保护间隔称为 保护频带 guard band；
* 正交频分复用 OFDM, Orthogonal FDM：基本思想是：每个子载波相互正交；即每个子载波在其他子载波的中心频率处能量为 0。这样在每个子载波中心频率处取样，就不会被其他子载波干扰了。这样的方式不需要 guard band，且频带利用率很高；

![img](https://cdn.nlark.com/yuque/0/2021/png/641515/1633669700504-b2555a6b-5874-4832-914a-6e5551ec170b.png)

- 

* 时分复用 TDM, Time Division Multiplexing
* 码分复用 CDM, Code Division Multiplexing

PCM：脉冲编码调制

### 2.6 蜂窝网络（CDMA）

码分多址（CDMA, Code Division Multiple Access）是 3G 系统的基础。

数据交换的几种方式：

* 电路交换 circuit switching：数据传输前，两个节点之间必须先建立一条专用（双方独占）的物理通信路径，分为三个阶段：连接建立-数据传输-连接释放；
* 报文交换 message switching：数据交换的单位是报文，在交换节点采用存储转发方式传输；
* 分组交换 package switching：包括虚电路 virtual circuit 和数据报 data gram。同样采用存储转发模式，但限制每次传送的数据块大小上限，将大的数据块划分为合理的的小数据块，再加上必要控制信息构成分组（packet）。数据报不保证可靠性，分组不一定有序到达，虚电路将数据报和电路交换结合，在通信双方之间里逻辑线路，数据分组需要有分组号、校验号和虚电路号等，提供可靠通信功能，保证每个分组正确且有序到达。

## 第3章 数据链路层（小于10分）
### 3.1 数据链路层的设计问题（Framing）
### 3.2 错误检测和纠正（Hamming distance, CRC）
### 3.4 滑动窗口协议

数据链路层可靠传输机制通过使用确认和超时重传两种机制完成。自动重传请求（ARQ，Automatic Repeat reQuest）通过接收方请求发送方重传出错的数据帧来恢复出错的帧。我们有以下三种 ARQ：

One-Bit Sliding Window Protocol 单帧滑动窗口协议（停止-等待协议 stop-and-wait）

* 发送窗口大小：1，接收窗口大小：1；
* 发送帧交替用 0 和 1 来标识，确认帧使用 ACK0 和 ACK1；
* 为了超时重发和判定重复帧需要，发送方和接收方都需要设置一个缓冲区。

Go-Back-N（GBN）后退 N 帧协议

* 发送窗口大小：$1 \le W_T \le 2^n-1$，接收窗口大小：1；
* 出现失序的信息帧后要求发送方重发最后一个正确接受的信息帧之后所有未被确认的帧；
* 可以在收到多个正确数据帧后确认（累积确认）或自己有数据发送时再带上确认帧一起发回（捎带确认 piggybacking），确认号 ACKn 表示收到第 n 号帧，期望收到 n + 1 号帧。

Selective Repeat 选择重传协议

* 发送窗口大小接收窗口大小之和不能超过 $2^n$，且发送窗口等于接受窗口，故二者最大均为 $2^{n-1}$；
* 可以收下不按序的序号，只需重发差错或超时的数据帧，因此无累积确认；
* 缓冲区大小等于窗口数目大小；
* 接收方怀疑帧出错，会发送否定帧 NAK 给发送方要求重传指定帧。

注意接受窗口大小为 1 可以保证按序接收。

## 第4章 介质访问控制子层（小于10分）
### 4.2 多路访问协议（MAC协议）

**CSMA（Carrier Sense Multiple Access 载波侦听多路访问，注意与码分复用 CDMA 区分）**

若每个站点发送前先侦听信道，发现信道空闲后再发送会大大降低冲突可能。CSMA 就是依据这一思想，它相对于 ALOHA 多了一个载波侦听装置。

有三种 CSMA 协议：

* 1-坚持 CSMA（1-persistent CSMA）：侦听信道空闲则立刻发送，冲突则继续坚持侦听直到空闲（持即续侦听信道直到空闲时立刻发出）；
* 非坚持 CSMA（Non-persistent CSMA）：侦听信道空闲则立刻发送，如果忙则放弃侦听，等待随机时间后再重复上述过程。这降低了多个结点同时等待信号空闲同时发送数据造成的冲突；
* $p$-坚持 CSMA（$p$-persistent CSMA）：侦听信道空闲则以概率 $p$ 立即发送，以概率 $1-p$ 推迟到下一个时隙，冲突则继续坚持侦听直到空闲，相当于前两种方案的折中。

**CSMA/CD（CSMA with Collision Detection 载波侦听多路访问/碰撞检测）**

1-坚持 CSMA 中传播延迟影响较大。结点 A 开始发送数据时，其发送数据的信号还未到达 B，B 侦听到信道空闲则发出，这样会导致冲突。于是 CSMA/CD 改为边发送边侦听。

要求帧的传输时长不小于 2 倍的传播时延（因为考虑往返），即：

最小帧长 = 2 $\times$ 总线传播延迟 $\times$ 数据传输速率（注意传输和传播的区别）

二进制指数退避算法（binary exponential back-off algorithm）

1. 确定基本退避时间，一般选取 2 倍总线端到端传播时延即 $2\tau$；
2. 从集合 $\{0,1,\cdots,2^k-1\}$ 中随机选择一个数 $r$，则退避时间为 $2r\tau$，其中 $k=\min\{重传次数，10\}$，即重传超过 10 次时 $k$ 不再增大，恒定为 10；
3. 当重传达到 16 次仍不成功则说明网络太拥挤，抛弃此帧并向高层报告出错。

**CSMA/CA（CSMA with Collision Avoidance 载波侦听多路访问/碰撞避免）**

无线局域网不能简单搬用 CSMA/CD，原因如下：

1. 无线网中接收信号强度远远小于发送信号强度，很难准确检测碰撞；
2. 无线通信中存在“隐蔽站”问题。

在这种情况下，我们采取冲突避免的方式，即发送数据前先广播告知其他节点。

802.11 要求发送方发送完一帧后，需收到对方确认后才能发送下一帧。并且为了避免碰撞，802.11 规定所有站完成发送后必须等待一段很短的时间（继续监听）才能发送下一帧，这段时间称为帧间间隔（InterFrame Space，IFS）。

处理隐蔽站问题：RTS 和 CTS（又称冲突避免多路访问 MACA，Multiple Access with Collision Avoidance）

![](./assets/MACA.png)

如图所示，对于（a），A 和 D 都能将数据发送给 B，且当 A 发送消息给 B 时，D 是无法听见的，因此 D 此时也可能给 B 发送数据，这时就会产生冲突。为了避免这种问题，我们引进 RTS（Request To Send）和 CTS（Clear To Send）帧，虑 当 A 向 B 发送一帧时的规则如下：

1. A 首先给 B 发送一个 RTS 帧，如图（a）所示。这个短帧（30 字节）包含了随后将要发送的数据帧的长度：
2. 然后，B 用一个 CTS 作为应答，如图（b ）所示。CTS 帧也包含了数据长度（从 RTS 帧中复制过来）；
3. A 在收到了 CTS 帧之后开始传输。

其他站听到了这些帧的反应（**注意区分不同情况下其他站在数据帧发送时能否发送数据**）：

1. 如果一个站听到了 RTS 帧，那么它一定离 A 很近，它必须保持沉默，至少等待足够长的时间以便在无冲突情况下 CTS 被返回给 A（只需等待 CTS 到达 A 即可，不影响后续数据传输）；
2. 如果一个站昕到了 CTS ，则它一定离 B 很近，在接下来的数据传送过程中它必须一直保持沉默，只要检查 CTS 帧，该站就可以知道数据帧的长度（即数据传输要持续多久）。

例如，①图中 C 落在 A 的范围内，但不在 B 的范围内。因此它听到了发出的 RTS 但没有听到  CTS，只要它没有干扰 CTS ，那么在之后的数据帧传送过程中，它可以自由地发送任何信息。②相反，D 落在 B 的范围内，但不在 A 的范围内。它听不到 RTS 帧但听到了CTS 帧，所以它就延缓发送任何信息直到数据帧如期传送完毕。③ E 站听到了这两条控制消息，一样在数据帧完成之前它必须保持安静。

尽管有了这些防范措施，冲突仍有可能会发生。例如， 可能同时给 B 发送 RTS 帧。这些帧将发生冲突，因而丢失。在发生了冲突的情况下，一个不成功的发送方（即在期望的时间间隔内没有听到 CTS）将等待一段随机的时间，以后再重试。

### 4.3 以太网*

在不考虑以太网前导码（preamble）的情况下：

* 以太网帧的最短为 64 字节，帧中的数据不得少于 46 个字节，以太网帧头有 18 字节，小于以上长度的帧或数据需要在帧中加入“填充数据（pad）”；
* 以太网帧的最长为 1518 字节。我们所说的 MTU  以太网一般为 1500，加上以太网帧头 18 字节。注意802.3 规范已经把最大长度改为 1536（即 0x0600）了。

高速以太网：速率达到或超过 100Mb/s 的以太网，分类如下：

1. 100BASE-T 以太网：双绞线（T）
2. 吉比特以太网：千兆以太网
3. 10 吉比特以太网：只使用光纤作为传输媒体，只工作在全双工方式，因此没有争用问题，也不使用 CDMA/CD 协议。

### 4.7 数据链路层交换**

交换机的每个端口都有各自的 MAC 地址。

## 第5章 网络层（非常非常重要）
### 5.1 网络层的设计问题

两种常见的传输技术（transmission technology）：单播（unicasting，或称点到点（point-to-point）链路）和广播链路（broadcast links）。

### 5.2 单个网络中的路由算法
### 5.7 Internet的网络层**

**NAT 网络地址转换**

NAT 是指通过将专用网络地址转换为公用地址从而对外隐藏内部管理的 IP 地址。内部 IP 地址可重用，故 NAT 节省了对 IP 地址的消耗，并降低了内部网络受到攻击的风险。

私有 IP 地址（private IP address）网段如下：

1. A类：1 个 A 类网段 **10**.0.0.0-**10**.255.255.255
2. B 类：16 个 B 类网段 **172.16**.0.0-**172.31**.255.255
3. C类：256 个 C 类网段：**192.168.0**.0-**192.168.255**.255

**路由协议**

Internet 由大量的独立网络或自治系统（AS, Autonomous System）构成，并由不同的组织运营，这些组织通常是公司、大学或 ISP。在自己网络内部，一个组织可以使用自己的域内路由算法（intradomain routing），域内路由协议也称为内部网关协议（IGP，interior gateway protocol）。而域间路由（interdomain routing）问题中所有网络必须使用相同的域间路由协议和外部网关协议（EGP，exterior gateway protocol）。

RIP（Routing Information Protocol，路由信息协议）

采用距离矢量路由（distance vector routing）算法

OSPF（ Open Shortest Path First，开放最短路径优先）

采用链路状态路由算法（link state routing）

BGP（Border Gateway Protocol，边界网关协议）

采用路径矢量协议（path vector protocol）

## 第6章 传输层（非常重要）
### 6.1 传输服务
### 6.2 传输协议的要素
### 6.4 Internet传输协议: UDP

使用 UDP 总结：

DHCP、DNS、RIP、实时传输协议（Real-time Transport Protocol，RTP）

### 6.5 Internet传输协议: TCP

Telnet协议是TCP/IP 协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力（TCP Port 23）、BGP、POP3、SMTP、IMAP、HTTP、FTP。

特别注意 TCP 的确认号是希望收到的下一个字节序号，不是滑动窗口 GBN 中目前收到的序号。

## 第7章 应用层（小于10分）
### 7.1 DNS——域名系统

**DNS 资源记录（resource record）**

* 格式为 Domain name 域名  Time to live 生存期  Class 类别  Type 类型  Value 值
* 域名：不一定需要包含 www；
* 生存期：指明了该条记录的稳定程度。极为稳定的信息会被分配一个很大的值，比如 86400（l 天的秒数〉，而非常不稳定的信息则会被分配一个较小的值，比如 60（l 分钟的秒数〉；
* 类别：对于 Internet 信息，它总是 IN 。对于非 Internet 信息，则可以使用其他的代码，但实际上很少见；
* 类型：如图所示

![](./assets/DNStype.png)

* 值：该字段的值可以是一个数字、一个域名或者一个 ASCII 字符串，其语义取决于记录的类型（详见上图中的描述）。

注意无论采取迭代查询还是递归查询，主机都只向本地域名服务器发请求，接下来本地域名服务器完成递归或迭代的任务。

### 7.2 电子邮件

**SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）**

* TCP 端口号 25；
* 从用户代理到发送方邮件服务器，以及邮件服务器之间传送都是基于 SMTP（push）；

**MIME（Multipurpose Internet Mail Extensions，多用途网络邮件扩充）**

* RFC 5322 是 Internet 邮件格式的最新版本，最初的 Internet 邮件格式由 RFC 822 描述；
* 继续使用 RFC 822 格式（在 RFC 5322 之前 MIME 就己被提出），但在邮件体中增加了结构性，并且为传送非 ASCII 码（基础的只能传送 ASCII 码）的邮件定义了编码规则，以下是 MIME 支持的内容类型：

![](./assets/MIMEtype.png)

* MIME 主要包括以下三部分内容：① 5 个新的邮件首部字段，包括 MIME 版本（MIME-Version）、内容描述（Content-Description）、内容标识（Content-ld）、传送编码（Content-Transfer-Encoding）和内容类型（Content-Type）；②定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化；③定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。

**POP3（Post Office Protocol，邮局协议）**

* TCP 端口号 110；
* 用户读取文件时，用户代理向邮件服务器发出请求（pull）；
* 两种工作方式：下载并保留（用户可以再次读取邮件），下载并删除（读取后邮件服务器删除该邮件）。

**IMAP（Internet Message Access Protocol，因特网报文存取协议）**

* TCP 端口号 143 ；
* 用户读取文件时，用户代理向邮件服务器发出请求（pull）；
* 功能比 POP 复杂，用户可以执行很多命令，包括列表显示文件夹和邮件、获取邮件或者甚至部分邮件、给邮件标记供以后删除，并将邮件组织到各文件夹内，也可以不通过邮件号而是使用属性来寻址邮件。

**Webmail 网络邮件**

一种日益流行可提供电子邮件服务的是 Web，它利用 Web 为用户提供邮件服务。浏览器与邮件服务器之间采用 HTTP 协议接收发送邮件，不同邮件服务器之间使用 SMTP。

### 7.3 万维网（web, url, cookie, javascript, php）

HTTP：无连接（无需建立 HTTP 连接），无状态（不会记录曾经访问过的客户），HTTP/1.1 默认持久连接（persistent connection）

![](./assets/HTTPstatus.png)

上表为 HTTP 状态码示例，1×× 码实际上很少被使用，2×× 码意味着这个请求被成功地处理，并且返回了相应的内容〈如果有的话〉，3×× 码告诉客户应该检查其他地方，使用另一个不同的 URL 或在它自己的缓存中查找，4×× 码意味着由于客户错误而导致请求失败，比如无效请求或者不存在的页面，最后 5×× 错误码意味着服务器自身出现内部问题，有可能是服务器代码中有错误，也可能是临时负载过重。

CDN（Content Delivery Network）内容分发网络

其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN 系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度。

## 第8章 网络安全（小于10分）

### 8.4 密码学+

* Kerckhoff 原则：所有的算法必须是公开的而密钥是保密的；

* 置换密码：凯撒密码，简单的字母替换；

* 替代密码：重新排序，不伪装明文，例如列换位密码，书写秘钥后，下方对齐秘钥逐行书写明文，最后根据秘钥中字母顺序重新排序各列；

* 一次性秘钥：生成随机位串与明文异或，是理论上绝对安全的，量子密码（如 BB84）可以实现一次性秘钥传输；
* 两个原则：①消息必须包含一定的冗余度 Messages must contain some redundancy；②需要采取某种方法来对抗重放攻击 Some method is needed to foil replay attacks，即要保证每条接收的消息都是 fresh 的，要对抗重放攻击。

### 8.5 对称密钥算法++

我们主要研究块密码，它接受一个 n 位的明文块作为输入，并利用密钥将它变换成 n 位的密文块。因此明文在进入加密算法前先需要进行填充和分组。

**乘积密码**

![](./assets/PSbox.png)

* 图（a）表示 P 盒，其作用为对输入重新排序（transposed 或 permuted），例如 01234567 重排为 36071245，注意 P 盒对 bit 进行操作；
* 图（b）表示 S 盒，其作用为置换（substitution），第一步译码将 3 bits 数转化为 8 种独热编码（one-hot，即只有一个为 1 其余均为 0 的编码）之一，例如 5 对应 00001000（第五位置 1，其余为 0），然后经过 P 盒将 1 换到其他位置最后编码回 3 bits 数，S 盒基于此实现了对更多位的置换；
* 图（c）结合了 P 盒与 S 盒，二者共同构成乘积密码（product cipher）。该图展示了通过多个小 S 盒近似达到一个大 S 盒的效果。若 S 盒能置换 n bits，则需要 $2^n$ 根线（注意独热编码），实现 $2^n$ 项的查询表（给所有 n bits 的二进制串各分配一项）；
* 对 k 位输入执行一个乘积密码算法以产生一个 k 位输出，这非常常见。典型情况下，k 介于 64～256。在许多文献中，这样的迭代称为轮（round）。

**数据加密标准（DES，Data Encryption Standard）**

DES 的基本结构如图所示，我们可以知道：

![](./assets/DES.png)

* 明文按 64 位数据块被加密，生成 64 位密文。DES 算法以一个 56 位密钥作为参数，它共有 19 个步骤；
* 第一步是一个与密钥无关的替代操作，它直接作用在 64 位明文上。最后一步是这个替代操作的逆操作。倒数第二步是交换左 32 位和右 32 位。剩下的 16 步在功能上完全相同，但使用了原始密钥的不同函数作为参数；
* 中间步骤如图（b）所示，每个步骤接受 2 个 32 位输入，并产生两个 32 位输出。左边的输出是右边输入的一份副本，右边的输出是左边输入与一个函数值逐位异或的结果；
* 该函数的输入参数有两个，分别是右边的输入和当前步骤所用的密钥 $K_i$。所有的复杂性都体现在这个函数中；
* 此函数包含 4 个顺序执行的步骤。①根据一个固定的替代和复制规则，将 32 位 $R_{i-1}$ 扩展成一个 48 位的数字 $E$。② $E$ 和 $K_i$ 异或，异或的结果分成 8 个 6 位组，每个 6 位组输入到不同 S 盒中。每个 S 盒有 64 种可能的输入，每种输入被映射到一个 4 位输出上；③最后，将这 8 $\times$ 4 位通过一个 P 盒；
* 每次迭代使用不同密钥。算法开始之前，先在 56 位的密钥上执行一个 56 位替代操作。在每一次迭代之前，密钥被分成两个 28 位，每个 28 位向左循环移位，移动的位数取决于当前的迭代次数。移位以后再执行另一个 56 位替代即可导出 $K_i$，每一轮从这 56 位中提取出不同的 48 位子集并对它进行排列；
* DES 算法解密的步骤只是加密步骤的相反顺序；
* 白化（whitening）可以增强 DES：每一个明文数据块送给 DES 前先用一个随机 64 位密钥对它执行异或操作，然后在传输之前对 DES 输出的结果密文用第二个 64 位密钥执行异或操作。去掉白化逆向操作即可（前提是接收方拥有这两个白化密钥）。这项技术有效增加了密钥长度，使得用穷举法来搜索密钥空间需要消耗更多的时间。请注意，每个明文数据块使用同样的白化密钥（即这里总共只有一个白化密钥）。

**三重 DES（Triple DES）**

Diffie 和 Helman（1977）利用穷举密钥设计了一台能破解 DES 的机器。IBM 公司意识到 DES 的密钥长度太短，于是利用三重加密来有效地增加密钥长度（Tuchman，1979）。所选择的方法如图所示：

![](./assets/TDES.png)

这种方法使用 2 个密钥，共包含了 3 个步骤。第 1 步按照常规的方式用密钥 $K_1$ 执行 DES 加密；在第 2 步中，DES 以解密方式运行，并使用 $K_2$ 作为密钥。最后，再次用 $K_1$ 执行 DES 加密；

**高级加密标准（AES，Advanced Encryption Standard）**

DES 被认为有后门且被破解，因此 NIST 采取竞赛方式收集算法，Rijndael 算法赢得了比赛。Rijndael 支持密钥长度和块的长度可以从 128 位一直到 256 位（以 32 位为间隔逐步向上递增），密钥长度和块长度可以独立选择。然而 AES 规定块长度必须是 128 位，密钥长度必须是 128、192 或者 256 位。事实上 AES 提供两个变种：①数据块为 128 位，密钥为 128 位；②数据块为 128 位，密钥为 256 位。

Rijndael 对于 128 位密钥和 128 位块长度的情形，轮数为 10；对于更长的密钥或者更长的数据块，轮数可以增加到 14。我们考虑 128 位密钥和 128 位块长度的情形。

* 函数 rijndael 有 3 个参数。它们分别是① plaintext（明文），一个包含输入数据的 16 字节数组；② ciphertext（密文），一个包含加密之后返回的输出结果的 16 字节的数组；③ key（密钥），是 16 字节长的密钥；
* 在计算过程中，数据的当前状态被保存在一个字节数组 state 中，该数组的长度为 NROWS $\times$ NCOLS。对于 128 位数据块，该数组为 4 $\times$ 4 字节。利用这 16 字节可以存储整个 128 位数据块。state 数组初始化为明文，每一步计算都要修改，最后 state 中内容作为密文返回；
* 首先将密钥扩展到 11 个与 state 同样长度的数组中。它们被保存在一个结构数组 rk 中，其中每个结构元素包含一个状态数组。 11 个数组中有一个用在计算过程开始，其他 10 个用在 10 轮计算中，每轮一个数组。简单来说轮密钥是通过反复地对密钥中不同的位组进行循环移位和异或操作而生成的；

![](./assets/AES.png)

* 接下来将明文复制到 state 中，复制过程按列的顺序进行，前 4 个字节复制到第 0 列中，接下来 4 个字节复制到第 1 列中，以此类推。除此之外，主要计算过程开始之前 rk[0] 需逐字节异或到 state 中；
* 主循环共 10 次迭代，每轮 4 个步骤：①逐字节的置换 state。每个字节按顺序作为索引查找 S 盒来替换该字节的值（相当于直接的单字母表置换密码）。注意DES 有多个 S 盒，但 Rijndael 只有一个；② 4 行中的每一行向左循环移动。第 0 行移动 0 字节（即不改变）；第 1 行左移 1 个字节；第 2 行左移 2 个字节；第 3 行左移 3 个字节；③列混合，列与列之间不相干。混合操作通过矩阵乘法完成，新的列是老的列与一个常量矩阵的乘积，这里的乘法是有限 Galois 域上的乘法，即 GF($2^8$)，可以用两个查表操作和三个 XOR 操作来计算；④最后将这一轮的密钥异或到 state 数组中以便下一轮使用；
* 由于每一步都是可逆的，所以解密过程也很简单，只要反过来运行这个算法的每一步即可。然而，通过使用技巧，也可以用该加密算法来完成解密，只是用到的数据表不相同。

**密码模式**

尽管 AES 算法（或者 DES，或者其他任何块密码算法）很复杂，但本质上只是一种单字母置换密码算法，不过使用了极大的字符（对于 AES 为 128 位字符，对于 DES 为 64 位字符），因为用同样的 DES 密钥加密明文 abcdefgh 100 次会得到同样的密文 100 次。入侵者可以充分发掘这种特性来协助攻破整个密码系统。

* 电码本模式（ECB，Electronic Code Book mode）：例如使用 DES 加密一长段明文需将它分割成连续的 8 字节（64 位）数据块，然后用同样的密钥逐个加密这些数据块。如果有必要的话，将最后一段明文填补至 64 位；

* 密码块链模式（CBC，Cipher Block Chaining mode）：电码本模式存在缺陷，即可以将密文分割得到的数据块重新排序，使得解密的明文可能还是有效的，但已经被篡改。为了对抗这种类型的攻击，所有的块密码算法可以按各种不同的方式链接起来。例如使用密码块链模式，**每个明文块加密前先与上一个密文块异或**。因此，同样的明文块不再被映射到同样的密文块上，加密操作也不再是一个大的单字母置换密码了。第一个块与一个随机选取的初始矢量（IV，Initialization vector）异或，该初始向量（以明文方式）随着密文一起被传输，如图所示：

![](./assets/CBC.png)

* 密码反馈模式（CFB，Cipher FeedBack mode）：密码块链模式也有一个缺点，即只有当整个 64 位数据块到达以后才可以开始解密。对于逐字节的加密应用，可以使用下图的密码反馈模式，它使用了（三重）DES。AES 基本思相同，只要使用 128 位移位寄存器即可。图中处于字节 0 至 9 已被加密并发送后的状态，当明文字节 10 到来时，DES 算法被作用在 64 位移位寄存器上，产生一个 64 位密文。该密文最左边的字节与 P$_{10}$ 异或然后传送到输出线路上，并且移位寄存器左移 8 位，C2 从最左边移走，C10 被插入到 C9 右边空出来的位置中。密码反馈模式的一个问题是，如果密文在传输过程中只有一位意外发生翻转，解密过程中，当坏字节位于移位寄存器中时所波及的 8 个字节都将遭到破坏。坏字节移出移位寄存器后明文仍然正确。因此**单位翻转错误只影响相对局部的区域，而不会破坏消息中其余剩下的部分，但是其影响的位数与移位寄存器的宽度相等**。

![](./assets/CFB.png)

* 流密码模式（stream cipher mode）：CFB 1 位错误影响 64 位明文较为严重，可以选择第四种方案，即流密码模式（stream cipher mode）。它用一个密钥来加密一个初始向量以便生成一个输出块；然后用同样的密钥对这个输出块进行加密以得到第二个输出块；再对这一块进行加密以生成第三块，依此类推而进行加密。输出块的序列（可以任意长）称为密钥流（keystream），它就像一次性密钥那样与明文做异或操作来生成密文。注意初始矢量 IV 仅仅被用在第一步中，此后输出数据块被加密。同时，密钥流与数据独立（数据在最后才与密钥流异或），所以可以将密钥流提前计算，而且它对于传输错误完全不敏感；与一次性秘钥相同，不要两次使用同样的（密钥，IV）对，因为这样使得每次都会生成同样的密钥流。两次使用同样的密钥流将导致密文受到密钥流重用攻击（keystream reuse attack），密码分析者只要将两个密文 XOR 在一起，就可以消除掉所有的密码保护，并获得明文的 XOR 结果；

![](./assets/SCM.png)

* 计数器模式（counter mode）：除电码本模式以外的模式想随机访问加密之后的数据是不可能的，然而磁盘文件通常访问随机块，这要求解密在它之前的所有数据块，这是非常昂贵的。因此发明了另一种模式，即计数器模式。明文并不直接被加密，被加密的是初始矢量加上一个常量的值，结果得到的密文再与明文做异或。通过“为每个新的数据块使初始向量递增 1”这种办法，在文件中任何地方的块都可以直接解密，而无需解密所有在它之前的数据块。它有一个弱点：假设同样的密钥 K 在将来又被使用了（明文不同，但 IV 相同），并且攻击者获得了这两次运行中所有的密文。这两种情形下的密钥流是相同的，从而使密码算法遭受密钥流重用攻击。

  ![](./assets/countermode.png)

### 8.6 公钥算法++

Diffie 和 Hellman 提出了一种全新的密码系统，在这种密码系统中，**加密密钥（公钥）和解密密钥（私钥）并不相同**，而且不可能很轻易地从加密密钥推导出解密密钥。在他们的提案中，（受密钥控制的）加密算法 E 和解密算法 D 必须满足 3 个要求：

1. D(E(P)) = P，即密码是可解密的； 
2. 从 E 推断出 D 极其困难，即很难从公钥推导出私钥；
3. E 不可能被选择明文（chosen plaintext）攻击破解。

**RSA**

该方法的名字来源于 3 个发现者名字的首字母（Rivest、Shamir、Adleman），主要缺点是要想达到好的安全性，密钥至少需要 1024 位（相比之下，对称密钥算法只需 128 位），这也使得它的运算速度非常慢。其安全性建立在分解大数的难度基础之上，流程如下：

1. 选择两个大的素数 p 和 q（保密，典型情况下为 1024 位）；
2. 计算 n = p $\times$ q（公开） 和 z = (p-1) $\times$ (q-1)；
3. 选择一个与 z 互素的数，将它称为 d（保密）。 
4. 找到 e（公开），使其满足 e $\times$ d = 1 mod z。

计算出这些参数以后开始执行加密。首先将明文（可以看作一个位串）分成块，使得每个明文消息 P 落在 0 $\le$ P < n 中（只要将明文划分成 $k$ 位的块即可，这里 $k$ 是满足 $2^k$ < n 的最大整数）。

1. 为了加密消息 P，只要计算 C = P$^e$ (mod n) 即可;
2. 为了解密 C，只要计算 P = C$^d$ (mod n) 即可;
3. 可以证明，对于指定范围内的所有 P，加密和解密函数互为反函数。

为了执行加密，你需要 e 和 n；为了执行解密，你需要 d 和 n。因此，公钥是由(e, n) 对组成的，而私钥是由 (d, n) 对组成的。

### 8.7 数字签名+

数字签名的要求：一方向另一方发送的签名消息必须满足以下条件： 

1. 接收方可以验证发送方所声称的身份；
2. 发送方以后不能否认该消息的内容‘
3. 接收方不可能自己编造这样的消息。

**对称密钥签名**

做法是设立一个人人都信任并且又熟知一切的中心权威机构，比如Big Brother（简称 BB）。每个用户选择一个秘密密钥，并且亲手将它送到 BB 的办公室。因此，只有 Alice 和 BB 才知道 Alice 的秘密密钥 $K_A$，如此等等。然后 Alice 使用自己的私钥，利用对称密钥加密数据就具有不可抵赖性了。

**公开密钥签名**

注意公私钥加密解密：

1. A 给 B 发送加密消息：A 使用 B 的公钥加密，B 使用 B 的私钥解密；
2. B 给 A 回信采用数字签名：B 先使用 Hash 函数（例如 SHA-1，SHA-2，MD5 等）生成摘要（digest），然后 B 使用 B 的私钥加密生成数字签名（signature），签名附在信件后；A 收到后用 B 的公钥解密，并生成摘要进行比对验证。

**生日攻击**

有人可能会认为，为了攻破一个 $m$ 位的消息摘要，将需要 $2^m$数量级的操作次数。事实上Yuval（1979）在他的论文 How to Swindle Rabin 中发表了一种生日攻击方法，用这种方法通常只需要 $2^{m/2}$ 量级的操作次数。

### 8.8 公钥管理

公钥密码体系获得他人的公钥不一定可靠，可能被其他人篡改，因此需要证书体系。

* CA（Certificate Authority，证书中心）发放证书（CA 可以有层次）
* CA 使用自己的私钥对对证书的 SHA-1 散列值进行签名
* 接收方使用 CA 的公钥进行签名验证
* X.509 为证书格式

### 8.9 认证协议++

认证（Authentication）是指这样的一项技术：一个进程通过认证过程来验证它的通信对方是否是它所期望的实体而不是假冒者。注意区分授权（authorization）和认证（authentication）这两个概念。

**基于共享密钥的认证**

我们假设 Alice 和 Bob 已经共享了一个密钥 $\rm K_{AB}$，这个协议以下面一个在许多其他的认证协议中都出现的原理为基础：一方给另一方发送一个随机数，后者将这个随机数做一个特殊的替代，再把结果返回给前者。这样的协议称为质询-回应（challenge-response）协议。

**建立共享密钥：Diffie-Hellman 密钥交换**

**使用密钥分发中心的认证**

**使用 Kerberos 的身份认证**

### 8.10 通信安全+

**IP 安全（IPSec，IP security）**

* 并不是所有的用户都想要加密功能（因为加密操作的计算代价较高），虽然 IPSec 并没有将加密功能做成可选项，它总是要求加密功能，但它允许使用**空算法（null algorithm）**。空算法因其简单、易于实现和极高的速度而获得了高度赞赏；
* 尽管它落在 IP 层，但它却是面向连接的。IPSec 环境中，一个“连接”称为一个安全关联（SA，security association）；
* 技术上，IPSec 有两个主要部分：①描述了两个新的头，这两个新的头可以被加入到数据包中以便携带安全标识符、完整性控制数据和其他的信息；② Internet 安全关联及密钥管理协议（ISAKMP，Internet Security Association and Key Management Protocol），处理建立密钥。ISAKMP 是个框架，用来开展工作的主要协议是 Internet 密钥交换（IKE，Internet Key Exchange）；
* IPSec 有两种使用模式：①传输模式（transport mode）中，IPSec 头被直接插在 IP 头的后面。IP 头中的 Protocol 字段要做相应的修改。IPSec 头包含了安全信息，主要是 SA 标识符、一个新的序号，可能还包括有效载荷数据的完整性检查信息；②隧道模式（tunnel mode）中，整个 IP 数据包，连同头和所有的数据一起被封装到一个新的 IP 数据包的数据部分，并且这个 IP 数据包有一个全新的 IP 头。当隧道的终点并不是最终的目标节点时，隧道模式将非常有用；
* IPsec有以下两种头，一个是认证头（AH，Authentication Header），另一个是封装的安全有效载荷（ESP，Encapsulating Security Payload），如图所示：

![](./assets/IPsecAH.png)

![](./assets/IPsecESP.png)

**防火墙（firewall）**

防火墙的作用就像一个包过滤器（packet filter）。它检查进出的每个数据包。通常只有那些符合网络管理员所定规则和条件的数据包才被放行，而那些不符合条件的数据包则被丢弃。 

![](./assets/firewall.png)

**虚拟专用网络（VPN，Virtual Private Networks）**

一个常见设计是在每个办事处都设置一个防火墙然后在所有办事处之间创建一条通过 Internet 的隧道。系统启动时，每一对防火墙必须协商它们的 SA 参数，包括服务、模式、算法和密钥。如果隧道采用了 IPSec，那么很可能要聚合两个办事处间所有流量组成一个经过认证的加密 SA。防火墙、VNP 和具有 ESP 的 IPSec（隧道模式）是很自然的一种组合，在实践中得到了广泛应用。

![](./assets/VPN.png)

**无线安全性**

802.11安全

部分 802.11 标准，最初称为 802.11i 规定了一个无线数据链路层安全协议，用来防止一个无线节点阅读或干扰另一对无线节点之间发送的消息。商标名称为 WiFi 保护接入 2（WPA2，WiFi Protected Access 2）。802.11i 是有线等效保（WEP，Wired Equivalent Privacy）的替代品，这是第一代 802.11 安全协议。

### 8.11 电子邮件安全+（PGP）

PGP（Pretty Good Privacy）-良好的隐私性

* 使用块密码算法 IDEA 国际数据加密算法加密数据，IDEA 类似于 DES / AES，允许多轮，但混合函数不一样。
* 密钥管理使用 RSA，数据完整性使用 MD5。

基本流程图如下：

![](./assets/PGP-1.png)

Alice 调用她自己机器上的 PGP 程序：

1. 使用 MD5 算法对消息 P 做散列运算，然后用 Alice 的 RSA 私钥 $D_A$加密此结果散列值；
2. 经过加密的散列值和原始消息 P 被串接成单条消息 P1，并且使用 ZIP 程序压缩（Ziv-Lempel 算法），压缩结果称为 P1.Z；
3. 接下来，PGP 提示 Alice 输入一些随机信息。输入的容和敲键速度被用来生成一个 128 位的 IDEA 邮件密钥 KM，按照密码反馈模式，利用 IDEA 算法和 KM 来加密 P1.Z。另外，使用 Bob 的公钥 $E_B$来加密 KM；
4. 然后两部分内容被串接，并转换成 base64 编码。结果邮件只包含字母、数字和符号 +、/ 和 =，这意味着该邮件可以被放到一个 RFC 822 邮件体中，有望未被修改地到达另一方。

当 Bob 得到此邮件时，他做一个逆向的 base64 编码，并且利用他自己的 RSA 私钥解密出 IDEA 密钥。利用这个密钥，他解密此邮件得到 P1.Z；再经过解压缩，Bob 将明文与加密的散列值分离开，并且使用 Alice 的公钥解密此散列值。如果得到的明文散列值与他自己计算的 MD5 散列值一致，那么，他知道 P 是正确的邮件，而且它确实来自于 Alice。

PGP 支持 4 种 RSA 密钥长度。它可以由用户选择一种最为合适的长度。这些长度选 项是： （1）临时的（384 位）：今天很容易被破解；（2）商用的（512 位）：可被三字母组织破解；（3）军用的（1024 位）：地球上的任何人都无法破解；（4）星际的（2048 位）：其他行星上的任何人也无法破解。

由于 RSA 仅仅被用在两个小的计算过程（加密 128 位的 MD5 散列值和加密 128 位 IDEA 密钥）中，所以，每个人在任何时候都应该使用星际强度的密钥。

经典 PGP 消息的格式如图所示，可以对照流程进行理解：

![](./assets/PGP-2.png)

PGP 的密钥管理模型：

每个用户在本地维护两个数据结构：一个私钥环和一个公钥环。

* 私钥环（private key ring）包含一个或者多个本人的“公钥/私钥”对。每一对“公钥/私钥”都有一个标识符与其关联，该标识符由公钥的低 64 位构成，所以邮件发送方可以告诉接收者自己是使用哪一个公钥来对它加密的。

* 公钥环（public key ring）包含了与当前用户通信的其他用户的公钥。公钥环上的每个条目不仅包含了公钥，而且也包含它的 64 位标识符，以及一个代表用户信任此密钥的强烈程度的指示值。
* 在 X.509 被标准化以后，PGP 除了支持传统的 PGP 公钥环机制以外，也支持X.509 证书。所有当前的 PGP 版本都支持 X.509。

S/MIME：略

### 8.12 Web安全+

**安全命名**

DNS 欺骗（DNS spoofing）：C 攻破 A 的 ISP 上的 DNS 缓存，将 B 的条目替换为自己的。做法是向 A 的 DNS 服务器请求 B 的条目（缓存中应没有 B 的条目，否则需要等待或运用其他高级手段），然后将预先准备好的伪造 UDP 答复先于真实的答复返回给 DNS 服务器即可产生错误的条目，得到染毒缓存（poisoned cache）。

DNS 安全（DNSsec，DNS Security）

实际上上述攻击并非这么简单，因为 DNS 回复需要检查需要，C 必须通过一定方法知道序号。实际上 C 是可以做到这一点的，因为 DNS 序号是递增的，因此j将这一序号随机处理就可以解决一定的问题。

当然 DNSsec 采取了更多的手段，它利用公钥技术①证明数据从哪里来；②分发公钥；③认证事务和请求。

**SSL**—**安全套接层**

SSL 在两个套接字之间建立一个安全的连接，其中包括以下功能：（1）客户与服务器之间的参数协商；（2）客户和服务器的双向认证；（3）保密的通信；（4）数据完整性保护。

SSL 安全层位于应用层和传输层之间，SSL 之上的 HTTP 称为 HTTPS，有时使用端口 443。

**移动代码安全性**

现在，Web 页面通常包含小程序，例如 Java Applet、ActiveX 控件和 JavaScript 等。下载并执行这样的移动代码（mobile code）很显然存在极大的安全风险。

Java小程序（Java Applet）

 Java 小程序插入到浏览器内部 JVM 解释器中。在经过编译的代码上再来运行解释性代码的好处是，解释器在执行每一条指令之前可以先对指令进行检查。解释器可能要将不可信任的 Java 小程序（比如它通过 Internet 进入本地机器）封装到一个沙箱（sandbox）中以便限制它的行为，并捕捉住它使用系统资源的企图。

ActiveX 

ActiveX 控件是可以被嵌入到 Web 页面中的 x86 二进制程序。当浏览器遇到一个 ActiveX 控件时，它就要对该控件进行基于代码签名（code signing）的检查。每个 ActiveX 控件都有一个利用公钥对代码散列值进行的数字签名。浏览器首先验证该控件的签名，签名正确则检查它的内部表，看该程序的创建者是否可信，或是否存在一条信任链可以回溯到某个可信的创建者。创建者可信则程序被执行；否则不予执行。Microsoft 用来验证 ActiveX 控件的系统称为认证码（Authenticode）。

对比 Jave 和 ActiveX。若采用 Java 方法，用户无法确定一个 Java 小程序是谁写的；但运行时解释器可以保证这个 Java 小程序不会做出该机器主人明确指明不允许做的事情。与此相反，若采用代码签名的方法，则浏览器不可能监视移动代码运行时的行为。

JavaScript 

JavaScript 没有任何正式的安全模型，但是却有很长的安全泄漏历史。基本的问题是让外部代码在你的机器上运行，这等于在自找麻烦。

浏览器扩展（Browser Extensions）

是用来扩展 Web 浏览器的计算机程序，提供了解释或者显示一定类型内容的能力，例如 PDF 或者 Flash 动画。安装浏览器扩展、外接附件或插件将使代码穿过 Internet 被下载和安装在浏览器上，如果安装的代码有问题，整个浏览器都将受到损害。

病毒（Viruses）

病毒与普通移动代码之间的区别在于病毒具有繁殖能力，它通常首先会感染硬盘上的可执行程序。当被感染的程序运行起来时，控制权被传递给病毒，它通常试图将自己传播到其他的机器。

